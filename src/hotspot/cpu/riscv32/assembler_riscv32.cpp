/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2014, Red Hat Inc. All rights reserved.
 * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.
 * Copyright (c) 2021, Institute of Software, Chinese Academy of Sciences. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

#include <stdio.h>
#include <sys/types.h>

#include "precompiled.hpp"
#include "asm/assembler.hpp"
#include "asm/assembler.inline.hpp"
#include "compiler/disassembler.hpp"
#include "interpreter/interpreter.hpp"
#include "memory/resourceArea.hpp"
#include "runtime/interfaceSupport.inline.hpp"
#include "runtime/sharedRuntime.hpp"

extern "C" void test_assembler_entry(CodeBuffer *cb);

#define __ _masm.

#ifdef ASSERT
static void asm_check(const unsigned int *insns, const unsigned int *insns1, size_t len) {
  assert_cond(insns != NULL && insns1 != NULL);
  bool ok = true;
  for (unsigned int i = 0; i < len; i++) {
    if (insns[i] != insns1[i]) {
      ok = false;
      printf("Ours:\n");
      Disassembler::decode((address)&insns1[i], (address)&insns1[i+1]);
      printf("Theirs:\n");
      Disassembler::decode((address)&insns[i], (address)&insns[i+1]);
      printf("\n");
    }
  }
  assert(ok, "Assembler smoke test failed");
}
#endif

void test_assembler_entry(CodeBuffer *cb) {
  MacroAssembler _masm(cb);
  address entry = __ pc();

#ifdef ASSERT
    // BEGIN  Generated code -- do not edit
    // Generated by riscv32-asmtest.py
    Label back, forth;
    __ bind(back);

// ArithOp
    __ add(x14, x13, x12);                             //       add     x14, x13, x12
    __ sub(x9, x16, x21);                              //       sub     x9, x16, x21
    __ orr(x4, x29, x26);                              //       or      x4, x29, x26
    __ xorr(x11, x20, x17);                            //       xor     x11, x20, x17
    __ mul(x3, x12, x31);                              //       mul     x3, x12, x31
    __ mulh(x27, x9, x25);                             //       mulh    x27, x9, x25
    __ mulhsu(x3, x28, x4);                            //       mulhsu  x3, x28, x4
    __ mulhu(x10, x30, x25);                           //       mulhu   x10, x30, x25
    __ div(x11, x26, x29);                             //       div     x11, x26, x29
    __ divu(x8, x2, x29);                              //       divu    x8, x2, x29
    __ rem(x20, x11, x16);                             //       rem     x20, x11, x16
    __ remu(x11, x10, x6);                             //       remu    x11, x10, x6
    __ andr(x11, x5, x31);                             //       and     x11, x5, x31

// AddSubImmOp
    __ addi(x2, x20, 794u);                            //       addi    x2, x20, 0x31a

// LogicalImmOp
    __ ori(x7, x25, 64u);                              //       ori     x7, x25, 0x40
    __ xori(x9, x2, 1787u);                            //       xori    x9, x2, 0x6fb
    __ andi(x30, x12, 328u);                           //       andi    x30, x12, 0x148

// AbsOp
    __ j(__ pc());                                     //       j       .
    __ j(back);                                        //       j       back
    __ j(forth);                                       //       j       forth
    __ jal(__ pc());                                   //       jal     .
    __ jal(back);                                      //       jal     back
    __ jal(forth);                                     //       jal     forth

// TwoRegAbsOp
    __ jalr(x19, x27, 1325u);                          //       jalr    x19, x27, 1325

// LoadImmedOp
    __ lui(x27, 0x3f1f8000);                           //       lui     x27, 0x3f1f8
    __ auipc(x30, 0x48ae2000);                         //       auipc   x30, 0x48ae2

// RegAndAbsOp
    __ bnez(x1, __ pc());                              //       bnez  x1, .
    __ bnez(x1, back);                                 //       bnez  x1, back
    __ bnez(x1, forth);                                //       bnez  x1, forth
    __ beqz(x27, __ pc());                             //       beqz  x27, .
    __ beqz(x27, back);                                //       beqz  x27, back
    __ beqz(x27, forth);                               //       beqz  x27, forth

// TwoRegAndAbsOp
    __ bne(x26, x13, __ pc());                         //       bne     x26, x13, .
    __ bne(x26, x13, back);                            //       bne     x26, x13, back
    __ bne(x26, x13, forth);                           //       bne     x26, x13, forth
    __ beq(x23, x22, __ pc());                         //       beq     x23, x22, .
    __ beq(x23, x22, back);                            //       beq     x23, x22, back
    __ beq(x23, x22, forth);                           //       beq     x23, x22, forth
    __ bge(x4, x25, __ pc());                          //       bge     x4, x25, .
    __ bge(x4, x25, back);                             //       bge     x4, x25, back
    __ bge(x4, x25, forth);                            //       bge     x4, x25, forth
    __ bgeu(x6, x18, __ pc());                         //       bgeu    x6, x18, .
    __ bgeu(x6, x18, back);                            //       bgeu    x6, x18, back
    __ bgeu(x6, x18, forth);                           //       bgeu    x6, x18, forth
    __ blt(x26, x3, __ pc());                          //       blt     x26, x3, .
    __ blt(x26, x3, back);                             //       blt     x26, x3, back
    __ blt(x26, x3, forth);                            //       blt     x26, x3, forth
    __ bltu(x21, x13, __ pc());                        //       bltu    x21, x13, .
    __ bltu(x21, x13, back);                           //       bltu    x21, x13, back
    __ bltu(x21, x13, forth);                          //       bltu    x21, x13, forth

// TwoRegImmedOp
    __ slti(x28, x4, 186u);                            //       slti    x28, x4, 186
    __ sltiu(x13, x18, 1617u);                         //       sltiu   x13, x18, 1617

// ShiftRegOp
    __ sll(x4, x4, x24);                               //       sll     x4, x4, x24
    __ srl(x15, x11, x21);                             //       srl     x15, x11, x21
    __ sra(x14, x13, x9);                              //       sra     x14, x13, x9

// ShiftImmOp
    __ slli(x21, x11, 1u);                             //       slli    x21, x11, 0x1
    __ srli(x17, x24, 6u);                             //       srli    x17, x24, 0x6
    __ srai(x6, x4, 12u);                              //       srai    x6, x4, 0xc

// Op
    __ nop();                                          //       nop
    __ ecall();                                        //       ecall
    __ ebreak();                                       //       ebreak
    __ fence_i();                                      //       fence.i

// SystemOp
    __ fence(15u, 8u);                                 //       fence   iorw, i

// AtomOp
    __ sc_w(x11, x19, x13, Assembler::aq);             //       sc.w.aq x11, x19, (x13)
    __ amoswap_w(x22, x16, x11, Assembler::aq);        //       amoswap.w.aq    x22, x11, (x16)
    __ amoadd_w(x4, x23, x22, Assembler::aq);          //       amoadd.w.aq     x4, x22, (x23)
    __ amoxor_w(x23, x23, x10, Assembler::aq);         //       amoxor.w.aq     x23, x10, (x23)
    __ amoand_w(x14, x30, x29, Assembler::aq);         //       amoand.w.aq     x14, x29, (x30)
    __ amoor_w(x7, x23, x24, Assembler::aq);           //       amoor.w.aq      x7, x24, (x23)
    __ amomin_w(x26, x24, x28, Assembler::aq);         //       amomin.w.aq     x26, x28, (x24)
    __ amomax_w(x17, x17, x13, Assembler::aq);         //       amomax.w.aq     x17, x13, (x17)
    __ amominu_w(x6, x26, x1, Assembler::aq);          //       amominu.w.aq    x6, x1, (x26)
    __ amomaxu_w(x3, x14, x20, Assembler::aq);         //       amomaxu.w.aq    x3, x20, (x14)
    __ lr_w(x8, x28, Assembler::aq);                   //       lr.w.aq x8, (x28)

// AtomOp
    __ sc_w(x7, x19, x15, Assembler::rl);              //       sc.w.rl x7, x19, (x15)
    __ amoswap_w(x13, x23, x8, Assembler::rl);         //       amoswap.w.rl    x13, x8, (x23)
    __ amoadd_w(x27, x23, x9, Assembler::rl);          //       amoadd.w.rl     x27, x9, (x23)
    __ amoxor_w(x10, x28, x15, Assembler::rl);         //       amoxor.w.rl     x10, x15, (x28)
    __ amoand_w(x15, x31, x12, Assembler::rl);         //       amoand.w.rl     x15, x12, (x31)
    __ amoor_w(x20, x17, x27, Assembler::rl);          //       amoor.w.rl      x20, x27, (x17)
    __ amomin_w(x30, x21, x10, Assembler::rl);         //       amomin.w.rl     x30, x10, (x21)
    __ amomax_w(x17, x1, x24, Assembler::rl);          //       amomax.w.rl     x17, x24, (x1)
    __ amominu_w(x27, x28, x5, Assembler::rl);         //       amominu.w.rl    x27, x5, (x28)
    __ amomaxu_w(x29, x10, x1, Assembler::rl);         //       amomaxu.w.rl    x29, x1, (x10)
    __ lr_w(x11, x31, Assembler::rl);                  //       lr.w.rl x11, (x31)

// OneRegOp
    __ frflags(x30);                                   //       frflags x30
    __ frrm(x18);                                      //       frrm    x18
    __ frcsr(x15);                                     //       frcsr   x15
    __ rdtime(x7);                                     //       rdtime  x7
    __ rdcycle(x29);                                   //       rdcycle x29
    __ rdinstret(x3);                                  //       rdinstret       x3

// TwoRegOp
    __ mv(x21, x18);                                   //       mv      x21, x18
    __ notr(x6, x30);                                  //       not     x6, x30
    __ neg(x6, x6);                                    //       neg     x6, x6
    __ seqz(x15, x22);                                 //       seqz    x15, x22
    __ snez(x2, x25);                                  //       snez    x2, x25
    __ sltz(x4, x23);                                  //       sltz    x4, x23
    __ sgtz(x22, x4);                                  //       sgtz    x22, x4
    __ fscsr(x6, x21);                                 //       fscsr   x6, x21
    __ fsrm(x11, x17);                                 //       fsrm    x11, x17
    __ fsflags(x31, x22);                              //       fsflags x31, x22

// ThreeRegOp
    __ slt(x31, x15, x18);                             //       slt     x31, x15, x18
    __ sltu(x2, x5, x12);                              //       sltu    x2, x5, x12

// CsrxixOp
    __ csrrw(x5, 1501, x3);                            //       csrrw   x5, 0x5dd, x3
    __ csrrs(x17, 1180, x26);                          //       csrrs   x17, 0x49c, x26
    __ csrrc(x28, 891, x20);                           //       csrrc   x28, 0x37b, x20

// CsrxiiOp
    __ csrrwi(x21, 1247, 10);                          //       csrrwi  x21, 0x4df, 10
    __ csrrsi(x11, 1140, 7);                           //       csrrsi  x11, 0x474, 7
    __ csrrci(x22, 64, 12);                            //       csrrci  x22, 0x40, 12

// CsrxiOp
    __ csrr(x20, 0x56f);                               //       csrr    x20, 0x56f

// CsrixOp
    __ csrw(0x54b, x15);                               //       csrw    0x54b, x15
    __ csrs(0x4ea, x3);                                //       csrs    0x4ea, x3
    __ csrc(0x262, x21);                               //       csrc    0x262, x21

// CsriiOp
    __ csrwi(0x706, 1);                                //       csrwi   0x706, 1
    __ csrsi(0x1c9, 3);                                //       csrsi   0x1c9, 3
    __ csrci(0xc7, 3);                                 //       csrci   0xc7, 3

// LoadStoreOp
    __ lw(x4, Address(x9, -1899));                     //       lw       x4, -1899(x9)
    __ lh(x5, Address(x7, 1002));                      //       lh       x5, 1002(x7)
    __ lhu(x3, Address(x9, 324));                      //       lhu      x3, 324(x9)
    __ lb(x16, Address(x8, -1399));                    //       lb       x16, -1399(x8)
    __ lbu(x23, Address(x4, -984));                    //       lbu      x23, -984(x4)
    __ sw(x12, Address(x6, -753));                     //       sw       x12, -753(x6)
    __ sh(x15, Address(x25, -1990));                   //       sh       x15, -1990(x25)
    __ sb(x25, Address(x29, -11));                     //       sb       x25, -11(x29)
    __ fld(f19, Address(x28, 976));                    //       fld      f19, 976(x28)
    __ flw(f8, Address(x30, -745));                    //       flw      f8, -745(x30)
    __ fsd(f17, Address(x1, -1022));                   //       fsd      f17, -1022(x1)
    __ fsw(f16, Address(x10, -1940));                  //       fsw      f16, -1940(x10)

// Float2ArithOp
    __ fsqrt_s(f22, f4, Assembler::rdn);               //       fsqrt.s f22, f4, rdn
    __ fsqrt_d(f1, f13, Assembler::rdn);               //       fsqrt.d f1, f13, rdn

// Float3ArithOp
    __ fadd_s(f1, f13, f16, Assembler::rup);           //       fadd.s  f1, f13, f16, rup
    __ fsub_s(f20, f15, f31, Assembler::rup);          //       fsub.s  f20, f15, f31, rup
    __ fadd_d(f28, f15, f14, Assembler::rup);          //       fadd.d  f28, f15, f14, rup
    __ fsub_d(f14, f31, f29, Assembler::rup);          //       fsub.d  f14, f31, f29, rup
    __ fmul_s(f12, f18, f31, Assembler::rup);          //       fmul.s  f12, f18, f31, rup
    __ fdiv_s(f26, f21, f24, Assembler::rup);          //       fdiv.s  f26, f21, f24, rup
    __ fmul_d(f25, f8, f22, Assembler::rup);           //       fmul.d  f25, f8, f22, rup
    __ fdiv_d(f11, f9, f26, Assembler::rup);           //       fdiv.d  f11, f9, f26, rup

// Float4ArithOp
    __ fmadd_s(f6, f10, f14, f8, Assembler::rup);      //       fmadd.s f6, f10, f14, f8, rup
    __ fmsub_s(f1, f5, f19, f15, Assembler::rtz);      //       fmsub.s f1, f5, f19, f15, rtz
    __ fmadd_d(f20, f31, f1, f1, Assembler::rup);      //       fmadd.d f20, f31, f1, f1, rup
    __ fmsub_d(f26, f13, f28, f4, Assembler::rtz);     //       fmsub.d f26, f13, f28, f4, rtz
    __ fnmsub_s(f4, f8, f30, f20, Assembler::rmm);     //       fnmsub.s        f4, f8, f30, f20, rmm
    __ fnmadd_s(f6, f8, f17, f13, Assembler::rtz);     //       fnmadd.s        f6, f8, f17, f13, rtz
    __ fnmsub_d(f25, f30, f8, f24, Assembler::rmm);    //       fnmsub.d        f25, f30, f8, f24, rmm
    __ fnmadd_d(f9, f8, f27, f28, Assembler::rtz);     //       fnmadd.d        f9, f8, f27, f28, rtz

// TwoRegFloatOp
    __ fclass_s(x26, f13);                             //       fclass.s        x26, f13
    __ fmv_s(f31, f5);                                 //       fmv.s   f31, f5
    __ fclass_d(x17, f14);                             //       fclass.d        x17, f14
    __ fmv_d(f18, f9);                                 //       fmv.d   f18, f9
    __ fabs_s(f19, f6);                                //       fabs.s  f19, f6
    __ fneg_s(f27, f9);                                //       fneg.s  f27, f9
    __ fabs_d(f16, f7);                                //       fabs.d  f16, f7
    __ fneg_d(f10, f9);                                //       fneg.d  f10, f9
    __ fmv_x_w(x11, f15);                              //       fmv.x.w x11, f15

// ThreeRegFloatOp
    __ fsgnj_s(f21, f11, f15);                         //       fsgnj.s f21, f11, f15
    __ fsgnjn_s(f23, f25, f16);                        //       fsgnjn.s        f23, f25, f16
    __ fsgnj_d(f25, f19, f26);                         //       fsgnj.d f25, f19, f26
    __ fsgnjn_d(f12, f4, f3);                          //       fsgnjn.d        f12, f4, f3
    __ fsgnjx_s(f9, f29, f20);                         //       fsgnjx.s        f9, f29, f20
    __ fmin_s(f7, f14, f19);                           //       fmin.s  f7, f14, f19
    __ fsgnjx_d(f3, f5, f3);                           //       fsgnjx.d        f3, f5, f3
    __ fmin_d(f16, f15, f20);                          //       fmin.d  f16, f15, f20
    __ fmax_s(f12, f25, f19);                          //       fmax.s  f12, f25, f19
    __ feq_s(x30, f3, f13);                            //       feq.s   x30, f3, f13
    __ fmax_d(f25, f20, f20);                          //       fmax.d  f25, f20, f20
    __ feq_d(x12, f29, f20);                           //       feq.d   x12, f29, f20
    __ flt_s(x10, f21, f28);                           //       flt.s   x10, f21, f28
    __ fle_s(x17, f10, f25);                           //       fle.s   x17, f10, f25
    __ flt_d(x20, f14, f22);                           //       flt.d   x20, f14, f22
    __ fle_d(x23, f3, f9);                             //       fle.d   x23, f3, f9

// FloatConvertOp
    __ fcvt_w_s(x21, f9, Assembler::rup);              //       fcvt.w.s        x21, f9, rup
    __ fcvt_wu_s(x11, f24, Assembler::rne);            //       fcvt.wu.s       x11, f24, rne
    __ fcvt_s_w(f20, x4, Assembler::rdn);              //       fcvt.s.w        f20, x4, rdn
    __ fcvt_s_wu(f21, x11, Assembler::rtz);            //       fcvt.s.wu       f21, x11, rtz
    __ fcvt_s_d(f1, f22, Assembler::rdn);              //       fcvt.s.d        f1, f22, rdn
    __ fcvt_d_s(f13, f15, Assembler::rne);             //       fcvt.d.s        f13, f15
    __ fcvt_w_d(x24, f21, Assembler::rdn);             //       fcvt.w.d        x24, f21, rdn
    __ fcvt_wu_d(x4, f3, Assembler::rdn);              //       fcvt.wu.d       x4, f3, rdn
    __ fcvt_d_w(f10, x30, Assembler::rne);             //       fcvt.d.w        f10, x30
    __ fcvt_d_wu(f2, x20, Assembler::rne);             //       fcvt.d.wu       f2, x20

    __ bind(forth);

/*
riscv32ops.o:     file format elf32-littleriscv


Disassembly of section .text:

00000000 <back>:
   0:   00c68733                add     a4,a3,a2
   4:   415804b3                sub     s1,a6,s5
   8:   01aee233                or      tp,t4,s10
   c:   011a45b3                xor     a1,s4,a7
  10:   03f601b3                mul     gp,a2,t6
  14:   03949db3                mulh    s11,s1,s9
  18:   024e21b3                mulhsu  gp,t3,tp
  1c:   039f3533                mulhu   a0,t5,s9
  20:   03dd45b3                div     a1,s10,t4
  24:   03d15433                divu    s0,sp,t4
  28:   0305ea33                rem     s4,a1,a6
  2c:   026575b3                remu    a1,a0,t1
  30:   01f2f5b3                and     a1,t0,t6
  34:   31aa0113                addi    sp,s4,794
  38:   040ce393                ori     t2,s9,64
  3c:   6fb14493                xori    s1,sp,1787
  40:   14867f13                andi    t5,a2,328
  44:   0000006f                j       44 <back+0x44>
  48:   fb9ff06f                j       0 <back>
  4c:   2880006f                j       2d4 <forth>
  50:   000000ef                jal     ra,50 <back+0x50>
  54:   fadff0ef                jal     ra,0 <back>
  58:   27c000ef                jal     ra,2d4 <forth>
  5c:   52dd89e7                jalr    s3,1325(s11)
  60:   3f1f8db7                lui     s11,0x3f1f8
  64:   48ae2f17                auipc   t5,0x48ae2
  68:   00009063                bnez    ra,68 <back+0x68>
  6c:   f8009ae3                bnez    ra,0 <back>
  70:   26009263                bnez    ra,2d4 <forth>
  74:   000d8063                beqz    s11,74 <back+0x74>
  78:   f80d84e3                beqz    s11,0 <back>
  7c:   240d8c63                beqz    s11,2d4 <forth>
  80:   00dd1063                bne     s10,a3,80 <back+0x80>
  84:   f6dd1ee3                bne     s10,a3,0 <back>
  88:   24dd1663                bne     s10,a3,2d4 <forth>
  8c:   016b8063                beq     s7,s6,8c <back+0x8c>
  90:   f76b88e3                beq     s7,s6,0 <back>
  94:   256b8063                beq     s7,s6,2d4 <forth>
  98:   01925063                bge     tp,s9,98 <back+0x98>
  9c:   f79252e3                bge     tp,s9,0 <back>
  a0:   23925a63                bge     tp,s9,2d4 <forth>
  a4:   01237063                bgeu    t1,s2,a4 <back+0xa4>
  a8:   f5237ce3                bgeu    t1,s2,0 <back>
  ac:   23237463                bgeu    t1,s2,2d4 <forth>
  b0:   003d4063                blt     s10,gp,b0 <back+0xb0>
  b4:   f43d46e3                blt     s10,gp,0 <back>
  b8:   203d4e63                blt     s10,gp,2d4 <forth>
  bc:   00dae063                bltu    s5,a3,bc <back+0xbc>
  c0:   f4dae0e3                bltu    s5,a3,0 <back>
  c4:   20dae863                bltu    s5,a3,2d4 <forth>
  c8:   0ba22e13                slti    t3,tp,186
  cc:   65193693                sltiu   a3,s2,1617
  d0:   01821233                sll     tp,tp,s8
  d4:   0155d7b3                srl     a5,a1,s5
  d8:   4096d733                sra     a4,a3,s1
  dc:   00159a93                slli    s5,a1,0x1
  e0:   006c5893                srli    a7,s8,0x6
  e4:   40c25313                srai    t1,tp,0xc
  e8:   00000013                nop
  ec:   00000073                ecall
  f0:   00100073                ebreak
  f4:   0000100f                fence.i
  f8:   0f80000f                fence   iorw,i
  fc:   1d36a5af                sc.w.aq a1,s3,(a3)
 100:   0cb82b2f                amoswap.w.aq    s6,a1,(a6)
 104:   056ba22f                amoadd.w.aq     tp,s6,(s7)
 108:   24ababaf                amoxor.w.aq     s7,a0,(s7)
 10c:   65df272f                amoand.w.aq     a4,t4,(t5)
 110:   458ba3af                amoor.w.aq      t2,s8,(s7)
 114:   85cc2d2f                amomin.w.aq     s10,t3,(s8)
 118:   a4d8a8af                amomax.w.aq     a7,a3,(a7)
 11c:   c41d232f                amominu.w.aq    t1,ra,(s10)
 120:   e54721af                amomaxu.w.aq    gp,s4,(a4)
 124:   140e242f                lr.w.aq s0,(t3)
 128:   1b37a3af                sc.w.rl t2,s3,(a5)
 12c:   0a8ba6af                amoswap.w.rl    a3,s0,(s7)
 130:   029badaf                amoadd.w.rl     s11,s1,(s7)
 134:   22fe252f                amoxor.w.rl     a0,a5,(t3)
 138:   62cfa7af                amoand.w.rl     a5,a2,(t6)
 13c:   43b8aa2f                amoor.w.rl      s4,s11,(a7)
 140:   82aaaf2f                amomin.w.rl     t5,a0,(s5)
 144:   a380a8af                amomax.w.rl     a7,s8,(ra)
 148:   c25e2daf                amominu.w.rl    s11,t0,(t3)
 14c:   e2152eaf                amomaxu.w.rl    t4,ra,(a0)
 150:   120fa5af                lr.w.rl a1,(t6)
 154:   00102f73                frflags t5
 158:   00202973                frrm    s2
 15c:   003027f3                frcsr   a5
 160:   c01023f3                rdtime  t2
 164:   c0002ef3                rdcycle t4
 168:   c02021f3                rdinstret       gp
 16c:   00090a93                mv      s5,s2
 170:   ffff4313                not     t1,t5
 174:   40600333                neg     t1,t1
 178:   001b3793                seqz    a5,s6
 17c:   01903133                snez    sp,s9
 180:   000ba233                sltz    tp,s7
 184:   00402b33                sgtz    s6,tp
 188:   003a9373                fscsr   t1,s5
 18c:   002895f3                fsrm    a1,a7
 190:   001b1ff3                fsflags t6,s6
 194:   0127afb3                slt     t6,a5,s2
 198:   00c2b133                sltu    sp,t0,a2
 19c:   5dd192f3                csrrw   t0,0x5dd,gp
 1a0:   49cd28f3                csrrs   a7,0x49c,s10
 1a4:   37ba3e73                csrrc   t3,0x37b,s4
 1a8:   4df55af3                csrrwi  s5,0x4df,10
 1ac:   4743e5f3                csrrsi  a1,0x474,7
 1b0:   04067b73                csrrci  s6,uscratch,12
 1b4:   56f02a73                csrr    s4,0x56f
 1b8:   54b79073                csrw    0x54b,a5
 1bc:   4ea1a073                csrs    0x4ea,gp
 1c0:   262ab073                csrc    0x262,s5
 1c4:   7060d073                csrwi   0x706,1
 1c8:   1c91e073                csrsi   0x1c9,3
 1cc:   0c71f073                csrci   0xc7,3
 1d0:   8954a203                lw      tp,-1899(s1)
 1d4:   3ea39283                lh      t0,1002(t2)
 1d8:   1444d183                lhu     gp,324(s1)
 1dc:   a8940803                lb      a6,-1399(s0)
 1e0:   c2824b83                lbu     s7,-984(tp) # fffffc28 <forth+0xfffff954>
 1e4:   d0c327a3                sw      a2,-753(t1)
 1e8:   82fc9d23                sh      a5,-1990(s9)
 1ec:   ff9e8aa3                sb      s9,-11(t4)
 1f0:   3d0e3987                fld     fs3,976(t3)
 1f4:   d17f2407                flw     fs0,-745(t5) # 48ae1d7b <forth+0x48ae1aa7>
 1f8:   c110b127                fsd     fa7,-1022(ra)
 1fc:   87052627                fsw     fa6,-1940(a0)
 200:   58022b53                fsqrt.s fs6,ft4,rdn
 204:   5a06a0d3                fsqrt.d ft1,fa3,rdn
 208:   0106b0d3                fadd.s  ft1,fa3,fa6,rup
 20c:   09f7ba53                fsub.s  fs4,fa5,ft11,rup
 210:   02e7be53                fadd.d  ft8,fa5,fa4,rup
 214:   0bdfb753                fsub.d  fa4,ft11,ft9,rup
 218:   11f93653                fmul.s  fa2,fs2,ft11,rup
 21c:   198abd53                fdiv.s  fs10,fs5,fs8,rup
 220:   13643cd3                fmul.d  fs9,fs0,fs6,rup
 224:   1ba4b5d3                fdiv.d  fa1,fs1,fs10,rup
 228:   40e53343                fmadd.s ft6,fa0,fa4,fs0,rup
 22c:   793290c7                fmsub.s ft1,ft5,fs3,fa5,rtz
 230:   0a1fba43                fmadd.d fs4,ft11,ft1,ft1,rup
 234:   23c69d47                fmsub.d fs10,fa3,ft8,ft4,rtz
 238:   a1e4424b                fnmsub.s        ft4,fs0,ft10,fs4,rmm
 23c:   6914134f                fnmadd.s        ft6,fs0,fa7,fa3,rtz
 240:   c28f4ccb                fnmsub.d        fs9,ft10,fs0,fs8,rmm
 244:   e3b414cf                fnmadd.d        fs1,fs0,fs11,ft8,rtz
 248:   e0069d53                fclass.s        s10,fa3
 24c:   20528fd3                fmv.s   ft11,ft5
 250:   e20718d3                fclass.d        a7,fa4
 254:   22948953                fmv.d   fs2,fs1
 258:   206329d3                fabs.s  fs3,ft6
 25c:   20949dd3                fneg.s  fs11,fs1
 260:   2273a853                fabs.d  fa6,ft7
 264:   22949553                fneg.d  fa0,fs1
 268:   e00785d3                fmv.x.w a1,fa5
 26c:   20f58ad3                fsgnj.s fs5,fa1,fa5
 270:   210c9bd3                fsgnjn.s        fs7,fs9,fa6
 274:   23a98cd3                fsgnj.d fs9,fs3,fs10
 278:   22321653                fsgnjn.d        fa2,ft4,ft3
 27c:   214ea4d3                fsgnjx.s        fs1,ft9,fs4
 280:   293703d3                fmin.s  ft7,fa4,fs3
 284:   2232a1d3                fsgnjx.d        ft3,ft5,ft3
 288:   2b478853                fmin.d  fa6,fa5,fs4
 28c:   293c9653                fmax.s  fa2,fs9,fs3
 290:   a0d1af53                feq.s   t5,ft3,fa3
 294:   2b4a1cd3                fmax.d  fs9,fs4,fs4
 298:   a34ea653                feq.d   a2,ft9,fs4
 29c:   a1ca9553                flt.s   a0,fs5,ft8
 2a0:   a19508d3                fle.s   a7,fa0,fs9
 2a4:   a3671a53                flt.d   s4,fa4,fs6
 2a8:   a2918bd3                fle.d   s7,ft3,fs1
 2ac:   c004bad3                fcvt.w.s        s5,fs1,rup
 2b0:   c01c05d3                fcvt.wu.s       a1,fs8,rne
 2b4:   d0022a53                fcvt.s.w        fs4,tp,rdn
 2b8:   d0159ad3                fcvt.s.wu       fs5,a1,rtz
 2bc:   401b20d3                fcvt.s.d        ft1,fs6,rdn
 2c0:   420786d3                fcvt.d.s        fa3,fa5
 2c4:   c20aac53                fcvt.w.d        s8,fs5,rdn
 2c8:   c211a253                fcvt.wu.d       tp,ft3,rdn
 2cc:   d20f0553                fcvt.d.w        fa0,t5
 2d0:   d21a0153                fcvt.d.wu       ft2,s4
 */

  static const unsigned int insns[] =
  {
    0x00c68733,     0x415804b3,     0x01aee233,     0x011a45b3,
    0x03f601b3,     0x03949db3,     0x024e21b3,     0x039f3533,
    0x03dd45b3,     0x03d15433,     0x0305ea33,     0x026575b3,
    0x01f2f5b3,     0x31aa0113,     0x040ce393,     0x6fb14493,
    0x14867f13,     0x0000006f,     0xfb9ff06f,     0x2880006f,
    0x000000ef,     0xfadff0ef,     0x27c000ef,     0x52dd89e7,
    0x3f1f8db7,     0x48ae2f17,     0x00009063,     0xf8009ae3,
    0x26009263,     0x000d8063,     0xf80d84e3,     0x240d8c63,
    0x00dd1063,     0xf6dd1ee3,     0x24dd1663,     0x016b8063,
    0xf76b88e3,     0x256b8063,     0x01925063,     0xf79252e3,
    0x23925a63,     0x01237063,     0xf5237ce3,     0x23237463,
    0x003d4063,     0xf43d46e3,     0x203d4e63,     0x00dae063,
    0xf4dae0e3,     0x20dae863,     0x0ba22e13,     0x65193693,
    0x01821233,     0x0155d7b3,     0x4096d733,     0x00159a93,
    0x006c5893,     0x40c25313,     0x00000013,     0x00000073,
    0x00100073,     0x0000100f,     0x0f80000f,     0x1d36a5af,
    0x0cb82b2f,     0x056ba22f,     0x24ababaf,     0x65df272f,
    0x458ba3af,     0x85cc2d2f,     0xa4d8a8af,     0xc41d232f,
    0xe54721af,     0x140e242f,     0x1b37a3af,     0x0a8ba6af,
    0x029badaf,     0x22fe252f,     0x62cfa7af,     0x43b8aa2f,
    0x82aaaf2f,     0xa380a8af,     0xc25e2daf,     0xe2152eaf,
    0x120fa5af,     0x00102f73,     0x00202973,     0x003027f3,
    0xc01023f3,     0xc0002ef3,     0xc02021f3,     0x00090a93,
    0xffff4313,     0x40600333,     0x001b3793,     0x01903133,
    0x000ba233,     0x00402b33,     0x003a9373,     0x002895f3,
    0x001b1ff3,     0x0127afb3,     0x00c2b133,     0x5dd192f3,
    0x49cd28f3,     0x37ba3e73,     0x4df55af3,     0x4743e5f3,
    0x04067b73,     0x56f02a73,     0x54b79073,     0x4ea1a073,
    0x262ab073,     0x7060d073,     0x1c91e073,     0x0c71f073,
    0x8954a203,     0x3ea39283,     0x1444d183,     0xa8940803,
    0xc2824b83,     0xd0c327a3,     0x82fc9d23,     0xff9e8aa3,
    0x3d0e3987,     0xd17f2407,     0xc110b127,     0x87052627,
    0x58022b53,     0x5a06a0d3,     0x0106b0d3,     0x09f7ba53,
    0x02e7be53,     0x0bdfb753,     0x11f93653,     0x198abd53,
    0x13643cd3,     0x1ba4b5d3,     0x40e53343,     0x793290c7,
    0x0a1fba43,     0x23c69d47,     0xa1e4424b,     0x6914134f,
    0xc28f4ccb,     0xe3b414cf,     0xe0069d53,     0x20528fd3,
    0xe20718d3,     0x22948953,     0x206329d3,     0x20949dd3,
    0x2273a853,     0x22949553,     0xe00785d3,     0x20f58ad3,
    0x210c9bd3,     0x23a98cd3,     0x22321653,     0x214ea4d3,
    0x293703d3,     0x2232a1d3,     0x2b478853,     0x293c9653,
    0xa0d1af53,     0x2b4a1cd3,     0xa34ea653,     0xa1ca9553,
    0xa19508d3,     0xa3671a53,     0xa2918bd3,     0xc004bad3,
    0xc01c05d3,     0xd0022a53,     0xd0159ad3,     0x401b20d3,
    0x420786d3,     0xc20aac53,     0xc211a253,     0xd20f0553,
    0xd21a0153, 
  };
// END  Generated code -- do not edit

  asm_check((unsigned int *)entry, insns, sizeof insns / sizeof insns[0]);
#endif
}

int AbstractAssembler::code_fill_byte() {
  return 0;
}

void Assembler::add(Register Rd, Register Rn, int32_t increment, Register temp) {
  if (is_imm_in_range(increment, 12, 0)) {
    addi(Rd, Rn, increment);
  } else {
    assert_different_registers(Rn, temp);
    li(temp, increment);
    add(Rd, Rn, temp);
  }
}

void Assembler::sub(Register Rd, Register Rn, int32_t decrement, Register temp) {
  if (is_imm_in_range(-decrement, 12, 0)) {
    addi(Rd, Rn, -decrement);
  } else {
    assert_different_registers(Rn, temp);
    li(temp, decrement);
    sub(Rd, Rn, temp);
  }
}

void Assembler::li(Register Rd, int32_t imm) {
  // int32_t is in range 0x8000 0000 ~ 0x7fff ffff, and imm[31] is the sign bit
  int32_t upper = imm, lower = imm;
  lower = (imm << 20) >> 20;
  upper -= lower;
  // lui Rd, imm[31:12] + imm[11]
  lui(Rd, upper);
  addi(Rd, Rd, lower);
}

#define INSN(NAME, REGISTER)                                       \
  void Assembler::NAME(const address &dest, Register temp) {       \
    assert_cond(dest != NULL);                                     \
    int32_t distance = dest - pc();                                \
    if (is_imm_in_range(distance, 20, 1)) {                        \
      jal(REGISTER, distance);                                     \
    } else {                                                       \
      assert(temp != noreg, "temp must not be empty register!");   \
      auipc(temp, (int32_t)dest + 0x800);                                  \
      jalr(REGISTER, temp, ((int32_t)dest << 20) >> 20);           \
    }                                                              \
  }                                                                \
  void Assembler::NAME(Label &l, Register temp) {                  \
    jal(REGISTER, l, temp);                                        \
  }                                                                \

  INSN(j,   x0);
  INSN(jal, x1);

#undef INSN

#define INSN(NAME, REGISTER)                                       \
  void Assembler::NAME(Register Rs) {                              \
    jalr(REGISTER, Rs, 0);                                         \
  }

  INSN(jr,   x0);
  INSN(jalr, x1);

#undef INSN

void Assembler::ret() {
  jalr(x0, x1, 0);
}

#define INSN(NAME, REGISTER)                                      \
  void Assembler::NAME(const address &dest, Register temp) {      \
    assert_cond(dest != NULL);                                    \
    assert(temp != noreg, "temp must not be empty register!");    \
    int32_t distance = dest - pc();                               \
    if (is_offset_in_range(distance, 32)) {                       \
      auipc(temp, distance + 0x800);                              \
      jalr(REGISTER, temp, (distance << 20) >> 20);               \
    }                                                             \
  }

  INSN(call, x1);
  INSN(tail, x0);

#undef INSN

#define INSN(NAME, REGISTER)                                 \
  void Assembler::NAME(const Address &adr, Register temp) {  \
    switch(adr.getMode()) {                                  \
    case Address::literal: {                                 \
      code_section()->relocate(pc(), adr.rspec());           \
      NAME(adr.target(), temp);                              \
      break;                                                 \
    }                                                        \
    case Address::base_plus_offset:{                         \
      int32_t offset = 0;                                    \
      baseOffset(temp, adr, offset);                         \
      jalr(REGISTER, temp, offset);                          \
      break;                                                 \
    }                                                        \
    default:                                                 \
      ShouldNotReachHere();                                  \
    }                                                        \
  }

  INSN(j,    x0);
  INSN(jal,  x1);
  INSN(call, x1);
  INSN(tail, x0);

#undef INSN

void Assembler::wrap_label(Register r1, Register r2, Label &L, compare_and_branch_insn insn,
                           compare_and_branch_label_insn neg_insn, bool is_far) {
  if (is_far) {
    Label done;
    (this->*neg_insn)(r1, r2, done, /* is_far */ false);
    j(L);
    bind(done);
  } else {
    if (L.is_bound()) {
      (this->*insn)(r1, r2, target(L));
    } else {
      L.add_patch_at(code(), locator());
      (this->*insn)(r1, r2, pc());
    }
  }
}

void Assembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {
  if (L.is_bound()) {
    (this->*insn)(Rt, target(L), tmp);
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(Rt, pc(), tmp);
  }
}

void Assembler::wrap_label(Register Rt, Label &L, jal_jalr_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(Rt, target(L));
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(Rt, pc());
  }
}

void Assembler::movptr(Register Rd, uintptr_t imm32) {
  movptr(Rd, (address)imm32);
}

void Assembler::movptr(Register Rd, address addr) {
  int offset = 0;
  lui(Rd, (int32_t)addr + 0x800);
  addi(Rd, Rd, ((int32_t)addr << 20) >> 20);
}

void Assembler::ifence() {
  fence_i();
  if (UseConservativeFence) {
    fence(ir, ir);
  }
}

#define INSN(NAME, NEG_INSN)                                                         \
  void Assembler::NAME(Register Rs, Register Rt, const address &dest) {              \
    NEG_INSN(Rt, Rs, dest);                                                          \
  }                                                                                  \
  void Assembler::NAME(Register Rs, Register Rt, Label &l, bool is_far) {            \
    NEG_INSN(Rt, Rs, l, is_far);                                                     \
  }

  INSN(bgt,  blt);
  INSN(ble,  bge);
  INSN(bgtu, bltu);
  INSN(bleu, bgeu);
#undef INSN

#undef __

Address::Address(address target, relocInfo::relocType rtype) : _base(noreg), _offset(0), _mode(literal) {
  _target = target;
  switch (rtype) {
  case relocInfo::oop_type:
  case relocInfo::metadata_type:
    // Oops are a special case. Normally they would be their own section
    // but in cases like icBuffer they are literals in the code stream that
    // we don't have a section for. We use none so that we get a literal address
    // which is always patchable.
    break;
  case relocInfo::external_word_type:
    _rspec = external_word_Relocation::spec(target);
    break;
  case relocInfo::internal_word_type:
    _rspec = internal_word_Relocation::spec(target);
    break;
  case relocInfo::opt_virtual_call_type:
    _rspec = opt_virtual_call_Relocation::spec();
    break;
  case relocInfo::static_call_type:
    _rspec = static_call_Relocation::spec();
    break;
  case relocInfo::runtime_call_type:
    _rspec = runtime_call_Relocation::spec();
    break;
  case relocInfo::poll_type:
  case relocInfo::poll_return_type:
    _rspec = Relocation::spec_simple(rtype);
    break;
  case relocInfo::none:
    _rspec = RelocationHolder::none;
    break;
  default:
    ShouldNotReachHere();
    break;
  }
}
